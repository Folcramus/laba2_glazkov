import numpy as np  # Импортируем библиотеку NumPy для работы с массивами и математическими функциями


# Определяем функцию Phi(x, y), которую мы будем минимизировать
def phi(x, y):
    return (np.cos(x - 1) + y - 0.5) ** 2 + (x - np.cos(y) - 3) ** 2


# Вычисляем градиент функции phi (частные производные по x и y)
def grad_phi(x, y):
    df_dx = -2 * (np.cos(x - 1) + y - 0.5) * np.sin(x - 1) + 2 * (x - np.cos(y))
    df_dy = 2 * (np.cos(x - 1) + y - 0.5) - 2 * (x - np.cos(y)) * np.sin(y)
    return np.array([df_dx, df_dy])  # Возвращаем градиент как массив [df/dx, df/dy]


# Метод скорейшего спуска (градиентный метод)
def steepest_descent(x0, y0, tol=1e-6, max_iter=10000):
    """
    Функция реализует метод градиентного спуска для минимизации функции phi.

    Аргументы:
    x0, y0 — начальные приближения.
    tol — критерий останова (точность).
    max_iter — максимальное количество итераций.

    Возвращает:
    x, y — координаты точки минимума.
    """
    x, y = x0, y0  # Начальные значения переменных

    for i in range(max_iter):  # Цикл выполняется, пока не достигнем максимального числа итераций
        x_old, y_old = x, y  # Сохраняем предыдущее значение x и y
        grad = grad_phi(x, y)  # Вычисляем градиент в текущей точке

        # Вычисляем шаг λ_k по формуле: λ_k = phi(x, y) / ||grad_phi(x, y)||^2
        lambda_k = phi(x, y) / np.dot(grad, grad)

        # Делаем шаг по направлению антиградиента
        x = x - lambda_k * grad[0]
        y = y - lambda_k * grad[1]

        # Проверяем условие останова по относительной разнице координат
        delta_num = abs(x - x_old) + abs(y - y_old)  # L1-норма разницы текущей и предыдущей точки
        delta_den = abs(x_old) + abs(y_old)  # L1-норма предыдущей точки

        if delta_den == 0:  # Чтобы избежать деления на ноль
            delta = delta_num
        else:
            delta = delta_num / delta_den  # Относительное изменение

        if delta < 0.001:  # Если изменение достаточно мало, останавливаем алгоритм
            break

    return x, y  # Возвращаем найденное значение x и y


# --- Тестирование алгоритма ---
# Первые начальные приближения
x0, y0 = 1.0, 2.0  # Начальная точка (1, 2)
x_sol, y_sol = steepest_descent(x0, y0)  # Запускаем метод
print("Начальные приближения:", x0, y0)
print(f"Решение: x = {x_sol}, y = {y_sol}\n")

# Вторые начальные приближения
x0, y0 = -1.0, -1.0  # Другая начальная точка (-1, -1)
x_sol, y_sol = steepest_descent(x0, y0)  # Запускаем метод снова
print("Начальные приближения:", x0, y0)
print(f"Решение: x = {x_sol}, y = {y_sol}")
